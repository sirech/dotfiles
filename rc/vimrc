" Example Vim configuration.
" Copy or symlink to ~/.vimrc or ~/_vimrc.

" --- Basics ---
set nocompatible                  " Must come first because it changes other options.

syntax enable                     " Turn on syntax highlighting.
filetype plugin indent on         " Turn on file type detection.

set encoding=utf-8

set showcmd                       " Display incomplete commands.
set showmode                      " Display the mode you're in.

set backspace=indent,eol,start    " Intuitive backspacing.

set hidden                        " Handle multiple buffers better.

set wildmenu                      " Enhanced command line completion.
set wildmode=list:longest         " Complete files like a shell.

set number                        " Show line numbers.
set ruler                         " Show cursor position.

" --- Mappings ---
" Remap escape
" (changed from <C-a> to avoid conflicts and recursion)
inoremap jk <Esc>

" --- Search ---
set incsearch                     " Highlight matches as you type.
set hlsearch                      " Highlight matches.
set ignorecase                    " Case-insensitive searching.
set smartcase                     " But case-sensitive if expression contains a capital letter.

" Clear search highlight
let mapleader=" "
nnoremap <silent> <leader>h :nohlsearch<CR>

" --- Wrapping ---
set wrap                          " Turn on line wrapping.
set linebreak                     " Break lines at word boundaries
set breakindent                   " Indent wrapped lines
set showbreak=↪\                 " Show wrap indicator

" Move by visual lines when wrapping
nnoremap j gj
nnoremap k gk

set scrolloff=3                   " Show 3 lines of context around the cursor.

set title                         " Set the terminal's title

set visualbell                    " No beeping.

" --- Files / backup / undo ---
set nobackup                      " Don't make a backup before overwriting a file.
set nowritebackup                 " And again.
set directory=$HOME/.vim/tmp//,.  " Keep swap files in one location

" Persistent undo
set undofile
set undodir=$HOME/.vim/undo//,.

set confirm                       " Ask instead of failing on unsaved changes
set autoread                      " Reload files changed outside Vim

" --- Indentation ---
" UNCOMMENT TO USE
"set tabstop=2                    " Global tab width.
"set shiftwidth=2                 " And again, related.
"set expandtab                    " Use spaces instead of tabs

set autoindent                    " Sensible auto indentation
set smartindent                   " Better indentation heuristics

" Filetype-specific indentation
autocmd FileType yaml,yml setlocal tabstop=2 shiftwidth=2 expandtab
autocmd FileType markdown setlocal tabstop=2 shiftwidth=2 expandtab

" --- Window behavior ---
set splitright                    " Vertical splits open to the right
set splitbelow                    " Horizontal splits open below

" --- Tabs ---
" Tab mappings.
nnoremap <silent> <leader>tt :tabnew<CR>
nnoremap <silent> <leader>te :tabedit<Space>
nnoremap <silent> <leader>tc :tabclose<CR>
nnoremap <silent> <leader>to :tabonly<CR>
nnoremap <silent> <leader>tn :tabnext<CR>
nnoremap <silent> <leader>tp :tabprevious<CR>
nnoremap <silent> <leader>tf :tabfirst<CR>
nnoremap <silent> <leader>tl :tablast<CR>
nnoremap <silent> <leader>tm :tabmove<Space>

" --- Airline-ish statusline (plugin-free, no git) ---
set laststatus=2
set noshowmode

let g:sl_left  = ''
let g:sl_right = ''

function! StatuslineModeLabel() abort
  let l:m = mode()
  return get({
        \ 'n':  'NORMAL',
        \ 'i':  'INSERT',
        \ 'v':  'VISUAL',
        \ 'V':  'V-LINE',
        \ "\<C-v>": 'V-BLOCK',
        \ 'R':  'REPLACE',
        \ 'c':  'COMMAND',
        \ 't':  'TERMINAL',
        \ }, l:m, toupper(l:m))
endfunction

function! StatuslineModeHi() abort
  let l:m = mode()

  " Normal/Insert/Replace/Command/Terminal
  if l:m ==# 'n' | return 'User9'  " NORMAL
  elseif l:m ==# 'i' | return 'User1'  " INSERT
  elseif l:m ==# 'R' | return 'User3'  " REPLACE
  elseif l:m ==# 'c' | return 'User10' " COMMAND-LINE
  elseif l:m ==# 't' | return 'User11' " TERMINAL

  " Visual
  elseif l:m ==# 'v' | return 'User2'  " VISUAL
  elseif l:m ==# 'V' | return 'User12' " V-LINE
  elseif l:m ==# "\<C-v>" | return 'User13' " V-BLOCK

  " Select mode (rare but exists)
  elseif l:m ==# 's' | return 'User14' " SELECT
  elseif l:m ==# 'S' | return 'User15' " S-LINE
  elseif l:m ==# "\<C-s>" | return 'User16' " S-BLOCK

  " Fallback
  else | return 'User9'
  endif
endfunction

function! StatuslineFlags() abort
  let l:f = []
  if &modified | call add(l:f, '+')     | endif
  if &readonly | call add(l:f, 'RO')    | endif
  if &paste    | call add(l:f, 'PASTE') | endif
  return empty(l:f) ? '' : join(l:f, ' ')
endfunction

function! StatuslineFileName() abort
  "return empty(expand('%:t')) ? '[No Name]' : expand('%:t')
  return empty(expand('%:~:.')) ? '[No Name]' : expand('%:~:.')
endfunction

function! StatuslineEnc() abort
  return empty(&fileencoding) ? &encoding : &fileencoding
endfunction

" Base statusline
hi StatusLine   cterm=NONE ctermfg=white ctermbg=darkgray
hi StatusLineNC cterm=NONE ctermfg=gray  ctermbg=black

" Separators / non-mode segments (keep your existing if you prefer)
hi User5  cterm=NONE ctermfg=black  ctermbg=darkgray  " separators
hi User6  cterm=NONE ctermfg=white  ctermbg=darkgray  " file
hi User7  cterm=NONE ctermfg=yellow ctermbg=darkgray  " flags
hi User8  cterm=NONE ctermfg=white  ctermbg=darkgray  " right side

" Mode colors (Spacemacs/Powerline-ish)
hi User9  cterm=bold ctermfg=black ctermbg=green      " NORMAL
hi User1  cterm=bold ctermfg=black ctermbg=blue       " INSERT
hi User2  cterm=bold ctermfg=black ctermbg=magenta    " VISUAL
hi User12 cterm=bold ctermfg=black ctermbg=darkmagenta " V-LINE
hi User13 cterm=bold ctermfg=black ctermbg=magenta    " V-BLOCK

hi User3  cterm=bold ctermfg=black ctermbg=red        " REPLACE
hi User10 cterm=bold ctermfg=black ctermbg=214        " COMMAND
hi User11 cterm=bold ctermfg=black ctermbg=cyan       " TERMINAL

hi User14 cterm=bold ctermfg=black ctermbg=cyan       " SELECT
hi User15 cterm=bold ctermfg=black ctermbg=darkcyan   " S-LINE
hi User16 cterm=bold ctermfg=black ctermbg=cyan       " S-BLOCK

" Build statusline safely (no :set escaping issues)
function! StatuslineBuild() abort
  let l:sl = ''

  " Mode segment (dynamic highlight)
  let l:sl .= '%#' . StatuslineModeHi() . '# ' . StatuslineModeLabel() . ' '
  let l:sl .= '%#User5#' . g:sl_left . '%*'

  " File segment
  let l:sl .= '%#User6# ' . StatuslineFileName() . ' '
  let l:sl .= '%#User5#' . g:sl_left . '%*'

  " Flags segment (only if non-empty)
  let l:flags = StatuslineFlags()
  if !empty(l:flags)
    let l:sl .= '%#User7# ' . l:flags . ' '
    let l:sl .= '%#StatusLine#%*'
  endif

  " Right align
  let l:sl .= '%='

  " Right: filetype + encoding + fileformat
  let l:sl .= '%#User5#' . g:sl_right . '%*'
  let l:sl .= '%#User8# %y ' . StatuslineEnc() . ' %{&fileformat} %*'

  " Right: position
  let l:sl .= '%#User5#' . g:sl_right . '%*'
  let l:sl .= '%#User8# %l:%c %p%% %*'

  return l:sl
endfunction

set statusline=%!StatuslineBuild()

